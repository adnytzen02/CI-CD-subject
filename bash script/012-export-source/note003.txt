# 環境變數簡介

Linux是一個多使用者的作業系統。   
每個使用者登入系統後，都會有一個專用的執行環境。   
通常每個使用者預設的環境都是相同的，這個預設環境實際上就是一組環境變數的定義。   
環境變數是全域性的，設定好的環境變數可以被所有當前使用者所執行的程式所使用。   
使用者可以對自己的執行環境進行定製，其方法就是修改相應的系統環境變數。   

常見的環境變數：
PATH：             決定了shell將到哪些目錄中尋找命令或程式
ROOTPATH:     這個變數的功能和PATH相同，但它只羅列出超級使用者（root）鍵入命令時所需檢查的目錄。
HOME：            當前使用者主目錄
USER:               檢視當前的使用者
LOGNAME：    檢視當前使用者的登入名。
UID：                當前使用者的識別字，取值是由數位構成的字串。
SHELL：           是指當前使用者用的是哪種Shell。
TERM ：           終端的型別。
PWD                 當前工作目錄的絕對路徑名，該變數的取值隨cd命令的使用而變化。
MAIL：             是指當前使用者的郵件存放目錄。
HISTSIZE：     是指儲存歷史命令記錄的條數
HOSTNAME： 是指主機的名稱，許多應用程式如果要用到主機名的話，通常是從這個環境變數中來取得的。
PS1：              是基本提示符，對於root使用者是#，對於普通使用者是$，也可以使用一些更復雜的值。
PS2：              是附屬提示符，預設是“>”。可以通過修改此環境變數來修改當前的命令符，比如下列命令會將提示符
                          修改成字串“Hello,My NewPrompt  ”。# PS1=" Hello,My NewPrompt  "
IFS：               輸入域分隔符。當shell讀取輸入時，用來分隔單詞的一組字元，它們通常是空格、製表符和換行符。

語言及環境字符集相關的重要環境變數：
     相關命令:
          stty 顯示或設定文字終端設定，主要是按鍵的代表意義
          locale (local environment)檢視當前的語系資訊
         【注：locale -a :檢視當前系統所支援的字符集】
     LANG   沒有設定任何LC_XXX變數時所使用的預設值。
        【LANG=zh.CN.UTF-8   gedit  a.txt  //臨時採用其它字符集語言開啟指定的應用程式】
     LC_ALL   用來覆蓋掉所有其他LC_XXX變數的值
     LC_COLLATE  使用所指定地區的排序規則
     LC_CTYPE  使用指定地區的字符集(即：字母,數字,標點符號等)
     LC_MESSAGES  使用所指定地區的響應與資訊;【注：僅POSIX適用】
     LC_MONETARY  使用指定地區的貨幣格式
     LC_NUMERIC  使用指定地區的數字格式
     LC_TIME   使用指定地區的日期與時間格式。

不太常用的實用環境變數:
　　LD_LIBRARY_PATH  這個變數包含了一系列用冒號隔開的目錄，動態連結器將在這些目錄裡查詢庫檔案。
　　MANPATH                  這個變數包含了一系列用冒號隔開的目錄，命令man會在這些目錄裡搜尋man頁面。
                                             【注:man幫助目錄結構必須為:man/{man1,man2,..man8}, MANPATH=/man】
　　INFODIR                    這個變數包含了一系列用冒號隔開的目錄，命令info將在這些目錄裡搜尋info頁面。
　　PAGER                      這個變數包含了瀏覽檔案內容的程式的路徑（例如less或者more）。
　　EDITOR                     這個變數包含了修改檔案內容的程式（檔案編輯器）的路徑（比如nano或者vi）。

系統位置變數—【僅用於shell指令碼中獲取命令列傳遞給指令碼的引數】
     $0、$1 $2 $3 $4 $5 $6 $7 $8 $9，$*   ——>$0到9與windows中0~9的含義一樣。
     $0:當前執行Shell檔名
     $#:命令列中位置引數的個數  
     $*:獲取當前shell的所有引數
     $@:此程式的所有引數

系統特殊變數 
     $?:上一條命令執行後返回的狀態，當返回值為0：表執行正常，非0：執行異常或出錯
            程式執行，可能有兩類返回值：
                 》0：正確執行
                 》1~255：錯誤執行。其中1,2,127 是系統預留錯誤程式碼,可自行使用   
     $$:當前所在程序的程序號 【$$變數最常見的用途是用做暫存檔案的名字以保證暫存檔案不會重複。】 
     $!:後臺執行的最後一個程序號         
     $_:在此之前執行命令或指令碼的最後一個引數 
   
引號對變數賦值的影響：
     》雙引號“”：允許通過$符號引用其他變數值  
     》單引號‘’： 禁止引用其他變數值，$視為普通字元   
     》反撇號` `：將命令執行的結果變輸出給變數 ,
                        $(…) :這是反撇號的另一種版本。
       
 二.Bash(Bourne-Again Shell)簡介
     Bash是許多Linux平臺的內定Shell，事實上，還有許多傳統UNIX上用的Shell，像tcsh、csh、ash、bsh、ksh
  等等。Shell Script大致都類同，當您學會一種Shell以後，其它的Shell會很快就上手。
  大多數的時候，一個Shell Script通常可以在很多種Shell上使用。
  通常而言，shell的功能是從終端或其它輸入取得命令列，將其解析為一系列操作指令，呼叫系統核心或相應的
  外部程式執行，然後將執行結果返回給終端或其它輸出。因此，實現一個簡單的shell是一項容易的工作。
  但bash的功能不僅限於此，它支援用管道和重定向協同執行命令，提供了強大的指令碼程式設計能力，
  具備作業管理功能。一般的Linux發行版中，bash的可執行檔案往往是/bin中最大的幾個實用程式之一，
  客觀反映了它的複雜性。
 
 三.Bash實現原理簡介
     bash使用GNU Readline庫處理使用者命令輸入，Readline提供類似於vi或emacs的行編輯功能。
     bash執行時的排程中心是其主控迴圈。主控迴圈的功能較為簡單，它迴圈讀取使用者（或指令碼）輸入，傳遞給
  語法分析器，同時處理下層遞迴返回的錯誤。
     語法分析器對文字形式的輸入首先進行萬用字元、別名、算術和變數展開等工作，然後通過命令生成器得到
  規範的命令結構，並由專門的重定向處理機制填寫重定向語義，交由命令執行器執行。命令執行器依據
  命令種類不同，執行內部命令函式、外部程式或檔案系統呼叫。在命令執行過程中，執行器要對系統訊號
  進行捕獲和處理。在支援作業管理的作業系統中，命令執行器將程序資訊加入作業控制機制，並允許使用者
  使用內部命令或鍵盤訊號來啟停作業。如果在不支援作業管理的作業系統中編譯bash，會使用另一套介面
  相同的機制對程序資訊進行簡單的維護。

四.Shell和環境變數的關係
      環境變數是和Shell緊密相關的，環境變數是通過Shell命令來設定的。使用者登入系統後就啟動了一個Shell。
  對於Linux來說一般是bash，但也可以重新設定或切換到其它的 Shell。
      設定好的環境變數又可以被所有當前使用者所執行的程式所使用。對於bash這個Shell程式來說，可以通過
  變數名來訪問相應的環境變數。
     Linux 的環境變數具有繼承性，即子shell 會繼承父shell 的環境變數。
     當前shell中的變數也叫本地變數，很顯然本地變數中肯定包含環境變數。Linux 的本地變數的非環境變數
  不具備繼承性。

五、登入指令碼的執行順序：【注：僅適用於 bash shell】
  Login Shell
       是指登入時，需要提供使用者名稱密碼的shell，如：su – user1 , 圖形登入， ctrl+alt+F2-6進入的登入介面。
     這種Login shell  執行指令碼的順序：
       1. /etc/profile       【全域性profile檔案;它定義了LoginUser的 PATH, USER, LOGNAME(登入使用者帳號)】
       2. /etc/profile.d/目錄下的指令碼
       3. ～/.bash_profile   【搜尋命令的路徑    ——————- 登入級別 環境變數配置檔案 】
       4. ～/.bashrc      【儲存使用者設定的別名和函式 ———- shell級別 環境變數配置檔案】
       5. /etc/bashrc     【全域性bashrc檔案; 它主要定義一些 Function 和 Alias；更改/etc/bashrc會影響到所有使用者,由root使用者管理。】
  Non-Login shell
       非登入shell指的是，不需要輸入使用者名稱密碼的shell，如圖形下 右鍵terminal，或ctrl+shift+T開啟的shell
     這種Non-Login shell 執行登入指令碼的順序： 
       1. ~/.bashrc
       2. /etc/bashrc
       3. /etc/profile.d/目錄下的指令碼
   說到使用者指令碼就不能不說下,與使用者密切相關的兩個檔案：
  1. /etc/login.defs   —– 它定義了使用者密碼長度,最長使用期,警告天數，密碼加密方法，家目錄預設許可權 等。 
  2. /etc/default/useradd  –它定義了建立使用者時,預設家目錄的根，預設shell,從哪裡拷貝必要配置檔案,是否建立郵箱等。
       /etc/skel –【.bashrc, .bash_profile, .bash_logout等檔案都源自這裡】
            當用命令新增一個使用者時，它預設會在/home/下新建一個以使用者名稱為名的目錄，並把/etc/skel下的檔案
           copy到這個新使用者的家目錄中。這樣當該使用者登入時，系統會自動呼叫這些檔案，配置該使用者的登入環境。

六. 環境變數的應用 和 操作：
     1.變數內容的刪除和替換
          ${變數#關鍵詞} 從頭開始檢查關鍵詞，將符合的最短資料刪除
          ${變數##關鍵詞} 從頭開始檢查關鍵詞，將符合的最長資料刪除
          ${變數%關鍵詞} 從尾開始檢查關鍵詞，將符合的最短資料刪除
          ${變數%%關鍵詞} 從尾開始檢查關鍵詞，將符合的最長資料刪除
          ${變數/舊字串/新字串} 若符合舊字串，則第一個舊字串被替換
          ${變數//舊字串/新字串} 若符合舊字串，則全部舊字串被替換
     2. 變數內容的設定和替換
          一次變數置換：
             變數沒有值：
                  echo ${a:=abc}   //若a沒有值，就送給a一個abc，作為它的值，這時a的值就永久是abc了，直到下次修改。
                 //下面例子不常用
                  echo ${a:?必須需要給變數一個值}   //若a沒有值，則提示"必須需要給變數一個值"
                  echo ${a:-abc}   //若a沒有值，就借給a一個值，次命令執行完後，a還是空值。
             變數有值
                  echo  ${a:+123}  //臨時替換變數的值; a=1; expr ${a:+123} – 1;其值為122
        二次變數置換 
            示例一：
                  A=B
                  a=1
                  B1="B值"
                  eval echo \$$A$a > B1.txt   //注意:這裡不能直接用反撇號獲取二次置換的結果。
                  C=`cat B1.txt`      //如此就可以獲取B1的變數值了.
           示例二：
                  FAIL="echo -e \"\n\e[31m\${FMSG}\e[0m\n\""
                  FMSG="需要紅色提示顯示的字串。"  &&  eval ${FAIL}
          示例三：
                  grep的結果："APPDIR="/home/abc/bin“"  通過eval可以直接將APPDIR轉換為賦值語句執行。
                  eval `grep '^ .*APPDIR'  /etc/tuxconfig`  
                  echo ${APPDIR}      //這樣就可以輸出APPDIR的值。

 七.一些Shell內建命令
     1.source命令
          作用:在當前bash環境下讀取並執行FileName中的命令，使環境變數生效。
          注：該命令通常用命令“.”來替代。
          例如：
               source ~/.bash_profile
     2.export ：
         用於把變數變成當前shell和其子shell的環境變數，存活期是當前的shell及其子shell，因此重新登陸或者關閉當前
        shell及其子shell後，它所設定的環境變數就消失了。
    3.env和printenv
          這兩個變數用於列印所有的環境 變數：
    4.set
          用於顯示與設定當前本地 變數。單獨一個set 就顯示了當前環境的所有的變數，它肯定包括環境變數和一些非環境變數
   5.unset
          用於清除變數。不管這個變數是環境變數還是本地變數，它都可以清除。

八.其它與變數相關的小知識
    shell : 屬於弱型別語言，變數可直接使用,不需要宣告和初始化。
            對於強型別語言，則必須在使用變數前先宣告，甚至需要初始化,因為變數不初始化其值為隨機數。
     變數： 它是記憶體空間的一個別名,這個別名對映的是記憶體的儲存單元的編址。
     陣列：是一個命名的連續的記憶體空間
     Shell的變數型別： 是事先確定資料的儲存格式和長度。
               字元：  是按照ASCII儲存;一個字串10,是儲存為兩個ASCII碼,佔16bit。
               數值:    
                    1.整型:    如10,它儲存時,是轉為二進位制1010,佔4bit,實際佔8bit.
                    2.浮點型: “11.23”,它在儲存時,是會轉為兩部分存放,
                             一般為數值和小數點位置,如11.23–>0.1123*10^2,儲存時僅存1123和次方數2.
                            如：2014/11/11在存放時,它是若按字串存64bit.
                               如按數值存則採用2014/11/11 – 1977/1/1 = N, 它若存N這個數值,需要的空間最多24bit. 
  
   變數溢位：
      一個整型是8bit,可存放的值有256個，範圍是0-255,但若一個整型中存放了256，最怎樣？結果就是變數溢位,
     8bit中存的是全0,1溢位了，溢位之後1被存放到其它程式的儲存空間中了，它可能覆蓋其它程式的資料。
     這看上去沒有任何意義，但若是一個設計精良的溢位值，則可能會因此覆蓋掉某些程式的一部分記憶體空間
     從而輕易的獲取該程式的控制權，若該程式是系統程序，則它將可能獲取系統許可權
  shell中陣列相關操作： —【注：shell中的陣列不能做為export匯出的物件,因此它僅不能作為環境變數】
        變數名=(Value1  Value2  Value3  Value4)
        a=(1  2  3  4  5)
                例子：
                    Cpu(s):  1.0%us,  0.5%sy,  0.0%ni, 98.5%id,  0.0%wa,  0.0%hi,  0.0%si,  0.0%st
                    a=(`top -n5 -d1 | awk '$1~/Cpu\(s\):/{print $2}' | awk -F'%' '{print $1}' | xargs -n5`)
                
        查陣列成員數
                echo  ${#a[*]}  —>前面加“#”，表示檢視陣列有多少個成員
        檢視成員值
                echo ${a[0]}  —>第一個陣列成員的值為  1.
                echo ${a[*]}  或  echo ${a[@]}   —>檢視所以成員的值
                declare  -p  a  —>檢視所有陣列成員。

                echo  ${a[*]:1:3}  —>檢視陣列中下標為1～3的成員值
